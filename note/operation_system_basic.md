1、 进程与线程

    ·进程状态：创建、就绪、运行、阻塞、结束
        当调用cv.wait、sleep会进入就绪态
        当调用cin、connect会等待io进入阻塞态
        当main结束或调用std::exit()进入结束态

    ·线程：c++<thread>标准库中线程是内核级线程，即可完美利用多核cpu。相反用户级线程不能跨cpu
        缺点是线程切换需要系统调用，创建/切换慢，应避免频繁切换线程，实际编程需要注意避免：
        1）短任务+高线程数
        2）锁粒度太细/竞争太激烈

2、 锁

    ·mutex lock：std::mutex是互斥锁，锁可获取时直接获取，不能获取则阻塞

    ·spin lock：std::spinlock是自旋锁，不能获取时忙等待，用于极端情况下优化

3、 信号量

    ·演进：作为古老的同步机制，直到c++20才完全补齐，底层来自linux和windows的api

    ·semaphore：std::counting_semaphore，实质是维护一个计数器，每当线程取用时计数器+1，释放时-1，计数器<0则阻塞
        简单场景，限制资源数可用信号量替代锁，复杂情况仍需要mutex+condition_variable

4、 管程

    ·概念：Monitor，封装共享资源在同一个容器中，通过锁互斥访问，通过条件变量同步
        std::mutex+std::condition_variable就是经典的管程实现

    ·条件变量：使用方法时wait与notify唤醒
        notify唤醒的是同一条件变量的wait，可以一/多个
        wait携带锁，并提供谓词判断，为true则继续执行，可能会虚假唤醒，所有一般显示检查谓词
        cv需要的锁类型需要能手动加解锁，因此用unique_lock

5、 同步问题

    ·生产者-消费者问题：使用管程

    ·读者-写者问题：使用std::shared_mutex，读线程用shared_lock，写线程用unique_lock

    ·哲学家问题：
        1）使用信号量限制为线程数-1
        2）破环循环等待，即在一开始就让两个线程互斥
    
    ·吸烟者问题：核心是解决多线程竞争有限资源
        1）复杂条件同步
        2）避免部分线程饥饿（资源提供尽量公平），以及死锁
        3）聚焦复合条件，而非单个资源，即同时拥有全部满足的资源才唤醒，而非只要有单个就直接抢占

    ·进程间同步：这时候一般使用更底层的接口，同样有锁、信号量等，还可以使用管道、消息队列等

6、死锁

    ·条件：互斥、不剥夺资源、请求与保持、循环等待

    ·解决：一般来说解决第三点即可，直接在所有资源都满足时才继续执行，在极端情况下会浪费系统资源，这时候再与破环循环等待结合使用

    ·银行家算法：类似于寻路，找寻最佳路径
        1）记录每种类型的最大资源数、持有资源数、可用资源数，然后计算每个线程的需要资源数
        2）找到一个需要资源数<可用资源数的，执行后继续寻找直到完成
        将所有线程的每种变量整合成矩阵方便计算

7、内存

    ·程序到内存：源代码编译成目标模块，然后链接成装入模块，由装入程序载入内存运行
        链接有静态链接、装入时动态链接与运行时动态链接
        cmake中target_link_libraries是前两者
        装入时动态链接会在程序开始时由操作系统加载共享
        运行时动态链接完全由程序控制

        因此要实现运行时替换逻辑是用运行时动态链接

    ·装入方式：可重定位装入（编译时使用相对地址，由装入程序loader计算绝对地址）、动态装入（运行时按需加载）
        windows/linux默认使用可重定位装入，嵌入式使用绝对装入，动态库、插件这些使用动态装入
        因为动态装入位置不确定，所以运行时要先获取到函数载入内存的地址才能使用

    ·拓展：程序编译后是汇编，汇编指令操作的都是相对地址，对于全局变量这些需要绝对地址的，会先赋予一个临时地址，然后标记为可重定位，操作系统中的loader会通过重定义表，根据程序的实际加载位置修正exe文件中的绝对地址引用
        现代程序完全基于相对寻址，只有全局变量需要重定位
        
        磁盘上的虚拟内存/交换文件设置，本质是将一部分磁盘用作内存的储备

    ·内存地址：即便由loader转换，此时的绝对地址依旧是虚拟地址，由MMU内存管理部件（硬件）转换为真实的物理地址
        这种转换涉及页表，由页号映射到物理块号

    ·进程内存映像：
        1）代码段：二进制只读
        2）数据段：已初始化全局变量和静态对象
            bss段，未初始化全局变量和静态对象
        3）进程控制块PCB：系统区，由操作系统管理
        4）堆
        5）栈
        6）共享库映射区
            装入时动态链接也会在这个区域
            相同动态库物理内存只有一份，由操作系统按需加载，然后映射到不同程序的存储映射区
        7）内存映射文件区

        以上‘段’，与段页式内存管理中的段一致，但现代操作系统弱化了段式管理，仅逻辑上区分

8、 文件系统/磁盘

    ·文件基本操作：
        1）创建文件
            filesystem::create_file("file")
            ofstream.open("file",std::ios::binary)
        2）写文件
            ofstream << / write
            fstream.seekp 移动写入位置
        3）读文件
            ifstream >> / read
            fstream.seekg 移动读取位置
        4）重定位文件
            fs::rename("file", "dir/newfile")
            重命名与移动到新目录
            fs::copy("source", "dest")
            跨盘符需要复制+删除本盘符文件
        5）删除文件
            filesystem::remove
            filesystem::remove_all删除文件夹
        6）截断文件
            ofstream("file")

        std::ios控制读写模式，app是追加写入，ate是定位到末尾，binary是二进制，out是清空然后打开，in无

        其他操作：
            fs::exists
            fs::file_size
            fs::last_write_time
            fs::last_access_time
            fs::status 文件类型和权限信息
            fs::is_directory
            fs::is_symlink
            fs::directory_iterator
            fs::recursive_directory_iterator
            fs::create_directories
            fs::filesystem_error

    ·文件描述符/文件句柄
        进程表内含有该进程打开的文件表（调用open），可以通过文件描述符/文件句柄对一打开文件进行操作

    ·权限控制 owner/group/x

9、 I/O

    ·DMA 直接存储器存取
        数据不经过cpu直接到内存，需要硬件支持

    ·衍生算法：
        1）双缓冲
            维护两个缓冲区，写方写完一个缓冲区后写第二个，只要有满的缓冲区，读方就会一直读取
            目的是提高并行程度
        2）循环缓冲
        3）缓冲池
