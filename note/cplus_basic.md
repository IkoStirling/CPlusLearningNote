1、 封装继承多态的理解

​封装​​
    
    ·​作用​​：将数据和操作数据的方法绑定在一个类中，隐藏内部实现细节，增强安全性和可维护性

    ·​优点​​：保护数据不被外部直接修改，提高代码模块化
    
    ·缺点​​：数据分散在对象中，可能影响缓存局部性，降低性能
    
    ·​优化方案​​：在性能敏感场景下，可将数据从类中提取出来，改用结构数组存储，再通过子系统或函数批量处理数据，提升访问效率
    
继承：

    ·​作用​​：子类继承父类的属性和方法，实现代码复用和层次化设计
    
    ·​优点​​：减少重复代码，增强扩展性
    
    ·​缺点​​：继承链过长会导致代码复杂度增加（“继承地狱”），降低可读性和灵活性
    
    ·​优化方案​​：优先使用组合（Composition）替代深层次继承，保持继承层级扁平化

​​多态​​

    ·​作用​​：允许不同子类对同一接口做出不同实现
    ​
    ·​优点​​：提高代码扩展性和灵活性，支持“开闭原则”（对扩展开放，对修改关闭）。

    ​​实现方式​​：通过虚函数与重载、重定义等机制。（一旦类中存在virtual关键字，类实例在生成时就会附带虚函数表，虚函数表中存在指针指向当前类中绑定的虚函数实现位置）

2、各种分区

代码区

    ·作用：存储程序的可执行指令，即编译后的机器码

    ·特点：存储在内存中，只读，多进程共享

    ·拓展：可执行文件中的机器指令，在运行时被加载到代码区

全局区

    ·作用：存储全局变量和静态变量，分为已初始化和未初始化，未初始化数据段默认置0

    ·特点：存储在内存中，程序启动时分配

    ·拓展：如static int x;会被放在未初始化数据段

栈区

    ·作用：存储局部变量、函数参数、返回地址等

    ·特点：自动管理，效率高，空间小，可能会栈溢出

    ·拓展：栈空间普遍在1~8MB，可随编译器选项调整

堆区

    ·作用：动态分配内存

    ·特点：手动管理，空间大，可能产生内存碎片或者内存泄漏

常量区

    ·作用：存储字符串常量、const修饰的全局变量等

    ·特点：位于代码段或者只读段

内存映射区

    ·作用：通过mmap将文件映射到进程地址空间，按需加载到内存

    ·特点：存储在磁盘上，部分由操作系统缓存到内存中

    ·拓展：动态库如果版本和内容相同（由操作系统判断），会被视为同一动态库文件，在内存中只会存在一份，不同程序会共用

3、左右值语法

左值

    ·特点：可取地址，位于等号左边

    ·用途：左值引用避免拷贝，如使用auto& x ： vec

右值

    ·特点：临时的，位于等号右边

    ·用途：移动语义与完美转发，如使用auto&& ref = std::move(val);

    ·拓展：移动就是窃取，被窃取后原有资源就不再持有了。std::forward+右值引用可以让模板保持参数类别

常量引用

    ·特点：按引用传递，避免修改

    ·拓展：虽然形式上与左值引用相同，只是增加了const，但是也支持传递右值

4、智能指针基础

make方式

    ·特点：一次性分配，控制块与内存存放位置一致

ptr方式

    ·特点：两次分配，控制块与内存存放位置可能分散

控制块

    ·特点：shared_ptr独有，记录引用技术，弱引用等元数据

删除器

    ·默认：默认删除器会调用全局new和delete，如果重载了new和delete，则需要自定义删除器

    ·拓展：sharedptr删除器在参数部分，在控制块，而uniqueptr删除器在模板，因此sharedptr中使用全局自定义删除器，并且不同删除器的sharedptr可以混合存储，而uniqueptr的存储容器必须标明删除器类型

5、不同的内存分配/释放

    ·malloc/free：仅分配和释放内存，不可重载，手动计算大小

    ·new/delete：在分配和释放同时还会调用构造和析构，可重载

    ·拓展：delete和free在调用时不需要传入大小，是因为在分配内存时，new和malloc都在内存指针前存储了固定结构大小的元数据
        placement new是new的另一个用法，直接在已分配的内存上构造对象，用法是 new(buffer) MyClass(12);
        因为char类型大小是1字节，可以用char类型指代字节进行内存分配

6、在使用define与const常量之间选择

    ·define：纯文本替换，无类型安全，不建议使用，只推荐用于生成某种框架性代码

    ·const：运行时常量

    ·constexpr：编译期计算结果的常量，可用作define的完美替代，结合inline可实现单例常量
        如constexpr int square(int x) { return x * x; }constexpr int val = square(5); 
        以上结果是在编译期就直接计算好的，不会占用运行时资源

        template + if constexpr()可以实现编译期分支
        template是在编译期生成的，if constexpr()也是在编译期计算的，到了运行时会被直接保留所选分支代码，移除非分支代码

7、生成可执行文件的步骤

    ·预编译：处理所有#开头的指令，包含头文件引入，宏替换，条件编译等，以及删除代码注释
        g++ -E main.cpp -o main.i

    ·编译：将预编译后的代码翻译成汇编指令，这里会进行词法分析（每个单词代表关键字、标识符、运算符等），语法分析（比如for循环写法等），语义分析（检查类型），优化
        g++ -S main.i -o main.s

    ·汇编：将汇编转换成机器码，也叫目标文件
        g++ -c main.s -o main.o

    ·链接：将多个目标文件和库文件合并成一个可执行文件
        g++ main.o -o main

    ·拓展：多模块项目时，cmake会在add_subdirectory时生成静态库文件，在target_link_libraries时仅会取用使用到的符号（符号囊括函数、变量等）生成.o为文件，并将这些文件合并在一起
        但是注意！！！以上并非发生在编译或链接阶段，仅定义如何构建项目，build构建广义上包含了生成可执行文件的全部步骤，最终基于add_executable中的名字生成可执行文件


9、class与struct

    ·struct：倾向于纯数据聚合，与C兼容

    ·class：倾向于复杂实现细节，封装继承多态等

    ·拓展：可以取缔继承体系，仅保留类数据作为struct，在结构体中预留类型，以供方法类判断


12、不同位置对象的生命周期

    ·new：对象生命周期持续到delete或者程序结束

    ·栈：与作用域有关，离开作用域销毁

    ·static：局部静态变量第一次执行到时初始化，程序结束时析构，全局与成员程序开始时初始化，程序结束时析构
        static关键字最直接的作用为，在保持作用域限制的同时，延长生命周期或限制可见性
        静态成员变量与局部静态变量都为类的所有实例共享，全局静态变量只在当前文件内可见

    ·全局：程序开始时初始化，程序结束时析构

    ·线程局部：线程启动时初始化，线程结束时析构

13、


    



    